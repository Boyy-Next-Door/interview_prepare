# RPC
## 是什么
Remote Procedure Call，远程过程调用，可以理解为在分布式架构下，多个服务进程直接进行网络交互的通用方案。

## RPC框架的构成
整个RPC功能可以描述为五个部分：
1. client

    远程调用的发起方
2. client Stub（桩）

    相当于client处所要调用的一个代理类，它会将client传入的函数名、入参进行组装成RpcRequest，并进行序列化；然后client需要找到对应函数的远程地址，发起具体的网络调用。
3. 网络传输
4. server Stub

    服务端RPC方法的具体实现，收到消息之后将其反序列化成RpcRequest，路由到本地方法并执行；将执行结果序列化成RpcResponse并返回给主调方的client Stub；client Stub拿到数据后反序列化成RpcResponse，再返回给业务。
5. server

    远程调用的被调方

## 业界采用使用比较多的几个RPC框架

- Dubbo

    一款由阿里开源的微服务框架，为大规模微服务实践提供高性能的RPC通信、流量治理、可观测性等解决方案，涵盖Java、Golang等多种语言SDK实现。

    Dubbo提供了服务定义、服务发现、服务通信、流量管控等几乎所有服务治理能力。它支持triple协议（基于http2.0的RPC通信协议）。
- gRPC

    google开源的高性能、通用的RPC框架。基于HTTP2协议开发（支持双向流、消息头压缩、二进制分帧多路复用），基于protobuf协议进行序列化/反序列化。

    gRPC的设计导致它几乎没有服务治理功能，解决这个问题需要引入其他的组件，例如腾讯的PolarisMesh（北极星），提供服务定义与注册、服务发现等功能。

- Motan

    新微博开源的RPC框架，像是一个精简版的Dubbo，设计更简单，功能更纯粹。

- Thrift

    facebook开源的跨语言RPC通信框架。

## 如何设计并实现一个RPC框架

考虑将整个RPC框架分成三个部分：
1. 主调方

    主调方需要有一个client，用来供业务调用，它需要能够对func寻址、负载均衡、对入参序列化、对响应反序列化。
2. 被调方

    背调方主要是具体实现func，服务启动时完成服务节点的注册，同样也需要支持序列化和反序列化。另一方面，还需要支持基于序列化协议（例如gRPC中的protobuf）生成桩代码，即将protobuf中定义的实体和func翻译成当前变成语言所支持的形式。
3. 注册中心

    RPC框架要提供一定的服务治理能力，这里就包括服务的定义、注册、活性管理、负载均衡等。

## 序列化协议

序列化指的是在client与server进行网络交互的过程中，业务层的「实体」的分解与组装的过程，为什么需要序列化协议这种东西？

打个比方，搬家时有一个很大的衣柜，衣柜里有很多隔层，隔层里又有很多很多不同体积的衣服；在搬家前后，希望保持柜子的结构、内部衣服摆放的位置都不变。

那么最最简单想到的方法，就是柜子原封不动地搬到目的地去，但是考虑到柜子的体积，链路上只能一件一件地运输东西，所以需要把衣柜给拆了，一件一件运到目的地再组装。

拆装之前，就需要拟定一份协议，来记录柜子的结构、衣服摆放的位置，这样才能确保它在被拆乱之后还能恢复原状。

一份高效的序列化协议，能够在确保数据恢复原样之外，让数据的分解、运输、组装过程尽可能的高效、占用更小的空间。

- json

    对比protobuf而言，json有着更简单的语法，他不需要提前定义对象的结构，而可以直接描述对象、数字、字符串、数组、布尔值等结构，并且它是肉眼可读的，对于开发人员非常友好。
- protobuf

    protobuf通过.proto文件，支持预先对数据结构、方法进行描述，它更适合与跨语言、跨技术栈之间的对接和并行开发（如果用json来规定接口出入参，还需要用实例数据和注释说明）。

    另外，protobuf序列化之后，数据是以二进制流的形式存储的，具体的，每一个字段在二进制中会变成「tag length value」的形式，相比于json中大量的引号、冒号，还有XML大量的<>和字段名，能节省大量的空间，巨幅提高序列化和网络传输的效率。但是也有确定，二进制的数据流肉眼不可读，必须在反序列化到某一个语言之后才能看到真实内容。