# 字符串
## KMP 字符串搜索
给出主串a和目标子串b，要寻找b在a中出现的位置，如果采用逐位遍历a来判断b是否出现的方法，那么最坏情况下时间复杂度为O(m*n)，其中m、n分别是a、b的长度。

使用KMP算法能将时间复杂度降低到O(m+n)，其核心思想是维护两个指针分别在a和b上移动，当p1和p2所指位置不相同时，p1保持不变，而p2往左回退到某一个位置，之后继续比较p1和p2处的字符是否相同。

这里所说的「p2往左回退到某一个位置」很巧妙，例如a串为abcabcaby  b串为abcaby，当p1=5、p2=5时，会发现这两个字符不一样，但是注意到，b串截止到p2之前的那一部分[abcab]，有相同的前缀和后缀ab。

而在a串截止到p1前的那部分正好就是ab，所以p2就可以向左回退到3，从c字符的位置继续与p1=5处的c进行比较。

所以本质上KMP是利用了子串的前缀，在每一次不字符不匹配的情况出现时，尽可能地利用之前已匹配的那部分，从而避免子串从头开始比较。

KMP中最核心的一部分就是目标串的前缀匹配表，例如目标串abcaby：

|  子串   | 最大前缀长度  |
|  ----  | ----  |
| a  | 0 |
| b  | 0 |
| c  | 0 |
| a  | 1 |
| b  | 2 |
| y  | 0 |

## 最长公共前缀
对字符串数组做排序，然后将第一个字符串和最后一个字符串的字符一个个做比较。
## 最长公共子串
最长公共子串  dp[i][j] = dp[i-1][j-1] + 1 if a[i] = b[j]  otherwise 0
## 最长公共子序列
最长公共子序列  dp[i][j] = dp[i-1][j-1] + 1 if a[i] = b[j]  otherwise max(dp[i-1][j], dp[i][j-1])





